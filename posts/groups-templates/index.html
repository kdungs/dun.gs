<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kevin's blog: Simple group structures via templates in C++ </title>
    <link rel="stylesheet" href="https://dun.gs/style.css">
    <link rel="stylesheet" type="text/css" href="https://dun.gs/syntax-theme.css">
  </head>
  <body>
    <header>
      <h1><a href="/">Kevin's blog</a></h1>
    </header>
    <main>
      
<article>
  <h1>Simple group structures via templates in C++</h1>
  <aside>
    <p>Posted on 2015-05-12.</p>
  </aside>
  <p>If you enjoyed the previous post on Simple Higher Order Functions in C++ you already got a taste of templates in C++. In this post we have a look at how we can implement compile-time <em>groups</em> in C++11. If you are unfamiliar with the concept of groups, you can read about them on <a href="https://en.wikipedia.org/wiki/Group_%28mathematics%29">Wikipedia</a> or <a href="http://mathworld.wolfram.com/Group.html">Wolfram MathWold</a>.</p>
<span id="continue-reading"></span>
<p>The code for this post can be found on <a href="https://github.com/kdungs/cpp-group-study">GitHub</a>.</p>
<p>For this example we look at O(1), a rather simple group structure. A possible incarnation of O(1) is ({1, -1}, ×). Here we call our elements <em>A</em> and <em>B</em> and for simplicity we omit the group operation sign. We want <em>AA=A</em>, <em>BB=A</em>, <em>AB=B</em>, and <em>BA=B</em>. <em>A</em> is the identity of the group. This group is also cyclic with order 1 and <em>B</em> being the generator.</p>
<p>First we create two types representing <em>A</em> and <em>B</em>:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">A</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">B</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>Next we need a type representing the binary group operation. That type should have two template parameters representing the left- and the right-hand side of the operator. We also need a type definition (here an alias) inside the type to specify the result of the operation.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> LHS<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c++">typename</span> RHS</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">Op</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">Op</span></span><span class="z-meta z-struct z-c++"><span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">result</span> <span class="z-keyword z-operator z-assignment z-c">=</span> A<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">Op</span></span><span class="z-meta z-struct z-c++"><span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">result</span> <span class="z-keyword z-operator z-assignment z-c">=</span> B<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> and so on…
</span></span></code></pre>
<p>We can verify that this does indeed work using static assertions. Assuming we have put our definitions from above in a file called <code>group.h</code>, the following program is sufficient to check that what we did is correct.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-preprocessor z-include z-c++"><span class="z-keyword z-control z-import z-include z-c++">#include</span> <span class="z-string z-quoted z-double z-include z-c++"><span class="z-punctuation z-definition z-string z-begin z-c++">&quot;</span>group.h<span class="z-punctuation z-definition z-string z-end z-c++">&quot;</span></span>
</span>
<span class="z-meta z-preprocessor z-include z-c++"><span class="z-keyword z-control z-import z-include z-c++">#include</span> <span class="z-string z-quoted z-other z-lt-gt z-include z-c++"><span class="z-punctuation z-definition z-string z-begin z-c++">&lt;</span>type_traits<span class="z-punctuation z-definition z-string z-end z-c++">&gt;</span></span>
</span>
<span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>A × A = A<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>A × B = B<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>B<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>B × A = B<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>B<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>B × B = A<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>save it as <code>test_group.cc</code> and compile it with <code>c++ -O3 -std=c++11 -o test_group.o test_group.cc</code>. The fact that is compiles implies correctness. Pretty cool, huh?</p>
<p>At this point, we are already able to use the result of a calculation as input for another one but there is a lot of syntactic overhead. For a simple example like <em>ABA</em>, we could write <code>Op&lt;Op&lt;A, B&gt;::result, A&gt;::result</code>. For <em>n</em> operands, we have to write <code>::result</code> <em>n-1</em> times.</p>
<p>When we defined our base case in the previous example, we did not specify a result type so using anything but <code>A</code> or <code>B</code> would fail. If instead we write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> LHS<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c++">typename</span> RHS</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">Op</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">result</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-storage z-modifier z-c++">typename</span> Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span><span class="z-storage z-modifier z-c++">typename</span> LHS<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span>
                             <span class="z-storage z-modifier z-c++">typename</span> RHS<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>it allows for expressions where both sides are the results of operations like</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-keyword z-operator z-comparison z-c">&lt;</span>Op<span class="z-keyword z-operator z-comparison z-c">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-separator z-c++">,</span> Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>B<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-keyword z-operator z-comparison z-c">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-keyword z-operator z-comparison z-c">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span>
              <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>(AB)(BA) = A<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>A simple modification to our initial definition of our types <code>A</code> and <code>B</code> will allow for more flexibility without having to specify all possible cases (<code>Op&lt;A, Op&lt;…&gt;&gt;</code>, <code>Op&lt;Op&lt;…&gt;, A&gt;</code>, …) manually:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">A</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"> <span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">result</span> <span class="z-keyword z-operator z-assignment z-c">=</span> A<span class="z-punctuation z-terminator z-c++">;</span> </span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">B</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"> <span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">result</span> <span class="z-keyword z-operator z-assignment z-c">=</span> B<span class="z-punctuation z-terminator z-c++">;</span> </span></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>Now we can even write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">x</span> <span class="z-keyword z-operator z-assignment z-c">=</span> Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>Op<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>A<span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-separator z-c++">,</span> B<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>result<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-keyword z-operator z-word z-c++">static_assert</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>is_same<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>x<span class="z-punctuation z-separator z-c++">,</span> A<span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-accessor z-double-colon z-c++">::</span>value<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>ABAABA = A<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>which is a significant improvement over how we had to do it before. Now we only have to write <code>::result</code> once independent of how many operations we perform. However, we still have to write <code>Op&lt;…&gt;</code> <em>n-1</em> times for n operations.</p>
<h2 id="variadic-templates">Variadic templates</h2>
<p>are awesome. They allow us to write functions and even types that take arbitrary numbers of (type) parameters. As an example think about this function:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">sum</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> x <span class="z-keyword z-operator z-arithmetic z-c">+</span> y<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>we can improve it with templates to take an arbitrary input type that supports addition:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> T</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
T <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">sum</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++">T <span class="z-variable z-parameter z-c++">lhs</span><span class="z-punctuation z-separator z-c++">,</span> T <span class="z-variable z-parameter z-c++">rhs</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> lhs <span class="z-keyword z-operator z-arithmetic z-c">+</span> rhs<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>but for summation of more than two values we would have to write another function or repeatedly apply <code>sum</code>. Writing a function for every possible case (three parameters, four parameters, …) is not only tiresome and unmaintainable it is also impossible as the number of parameters goes to infinity. Repeatedly applying the function works better but who really wants to write <code>sum(sum(sum(sum(sum(…)…)…)…)…)</code>?</p>
<p>With just four lines of code, we are able to solve that problem:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> T<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c++">typename</span><span class="z-keyword z-operator z-variadic z-c++">...</span> Ts</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
T <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">sum</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++">T <span class="z-variable z-parameter z-c++">head</span><span class="z-punctuation z-separator z-c++">,</span> Ts<span class="z-keyword z-operator z-variadic z-c">...</span> <span class="z-variable z-parameter z-c++">tail</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> head <span class="z-keyword z-operator z-arithmetic z-c">+</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">sum</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">tail<span class="z-keyword z-operator z-variadic z-c">...</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>The three dots (<code>...</code> not <code>…</code>) indicate the use of what is called a <em>parameter pack</em>. Parameter packs are at the core of variadic templates. You can find an excellent and comprehensive description on <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">cppreference.com</a>.</p>
<p>If you call <code>sum(1, 2, 3, 4)</code> somewhere in your code, your compiler should theoretically generate <code>sum</code> functions taking four, three, and two parameters. However, modern compilers are smart enough to not actually do this and optimise most of it away. In fact, the generated assembly file (clang option <code>-S</code>) for this program is only a few lines long and contains no function calls whatsoever.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-preprocessor z-include z-c++"><span class="z-keyword z-control z-import z-include z-c++">#include</span> <span class="z-string z-quoted z-double z-include z-c++"><span class="z-punctuation z-definition z-string z-begin z-c++">&quot;</span>variadic.h<span class="z-punctuation z-definition z-string z-end z-c++">&quot;</span></span>
</span>
<span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">main</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">sum</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">2</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">3</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-constant z-numeric z-integer z-decimal z-c++">4</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<h2 id="back-to-our-group">Back to our group</h2>
<p>In order to apply what we've learned about variadic templates and parameter packs to our original problem we just need to consider one difference between functions and types: There is no type overloading in C++. In the <code>sum</code> example it was okay to first define the base case (two parameters) and then specify the more common case but when working with types we must define the most common case first:</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span><span class="z-keyword z-operator z-variadic z-c++">...</span></span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-meta z-struct z-c++"><span class="z-storage z-type z-c++">struct</span> </span><span class="z-meta z-struct z-c++"><span class="z-entity z-name z-struct z-c++">Op</span></span><span class="z-meta z-struct z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-struct z-c++"></span><span class="z-meta z-struct z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>Our initial definition then becomes a <em>specialisation</em> of this template:</p>
<p>``cpp
template &lt;typename LHS, typename... RHS&gt;
struct Op&lt;LHS, RHS...&gt; {
using result =
typename Op&lt;typename LHS::result,
typename Op&lt;RHS...&gt;::result&gt;::result;
};</p>
<pre class="z-code"><code><span class="z-text z-plain">
Notice how we use the same recursive structure as in the above example. Functional programmers will recognise this pattern as a _fold_.

And indeed, this assertion holds, showing that our code works the way we want it to

```cpp
static_assert(
  std::is_same&lt;Op&lt;A, A, A, B, A, B, B, A&gt;::result, B&gt;::value,
  &quot;AAABABBA = B&quot;
);
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Using a somewhat contrived example of an O(1) group, we have learned how to implement compile-time calculations on arbitrary structures. We also had a look at <em>parameter packs</em> and <em>variadic templates</em> that allow us to write very generic and highly re-usable code.</p>
<h2 id="questions-remarks">Questions, remarks, …</h2>
<p>Do you have any questions? Is anything unclear? Did I get something wrong? Is something horribly imprecise? Please let me know! <a href="https://github.com/kdungs/dun.gs/issues/5">Go to the corresponding issue on GitHub, in order to discuss this article.</a></p>

</article>

    </main>
  </body>
</html>
