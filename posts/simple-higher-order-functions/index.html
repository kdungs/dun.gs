<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kevin's blog: Simple higher order functions in C++ </title>
    <link rel="stylesheet" href="https://dun.gs/style.css">
    <link rel="stylesheet" type="text/css" href="https://dun.gs/syntax-theme.css">
  </head>
  <body>
    <header>
      <h1><a href="/">Kevin's blog</a></h1>
    </header>
    <main>
      
<article>
  <h1>Simple higher order functions in C++</h1>
  <aside>
    <p>Posted on 2015-04-17.</p>
  </aside>
  <p>Here is a question from a friend of mine that I will try to answer in this post:</p>
<blockquote>
<p>I have the problem that I want to pass a function to a function. Until now, I have used <code>std::function</code> but I know there is also the possibility of function pointers and also you said something about templates and who knows what else. The question is of course: What's the difference and what is best?</p>
</blockquote>
<p>In technical terms the question is: &quot;How do <strong>higher-order functions</strong> work in C++ and which way to implement them is recommended?&quot;. I will examine the problem in two steps and then discuss the alternatives.</p>
<span id="continue-reading"></span><h2 id="functions-in-c">Functions in C++</h2>
<p>What exactly is a &quot;function&quot; in C++? For the purpose of this exercise let's limit ourselves to <em>mathematical</em> functions that return a value from a number of parameters without side-effects (a.k.a. <em>pure</em> functions).</p>
<p>Assuming a function <code>add</code> that takes two <code>int</code>s as input and returns an <code>int</code> representing their sum we want to be able to write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> z <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">add</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">add</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-constant z-numeric z-integer z-decimal z-c++">1</span><span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>and similar stuff. There are multiple ways to define <code>add</code> such that it fulfils our demand.</p>
<h3 id="standard-function-definitions">Standard Function Definitions</h3>
<p>The usual approach to defining a function C++ is of course the well-known</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">add</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> x <span class="z-keyword z-operator z-arithmetic z-c">+</span> y<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>which already existed in C, is simple, and gets the job done.</p>
<h3 id="function-objects">Function Objects</h3>
<p>Another way to define <code>add</code> such that it can be used in the above example would be by defining a class with a <code>()</code> operator. An instance of such a class will be <em>callable</em>. Some people refer to those classes (or objects instantiated from them) as &quot;functors&quot;, but they are wrong ;).</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-class z-c++"><span class="z-storage z-type z-c++">class</span> </span><span class="z-meta z-class z-c++"><span class="z-entity z-name z-class z-c++">Adder</span></span><span class="z-meta z-class z-c++"> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-class z-c++"><span class="z-meta z-block z-c++">
 <span class="z-storage z-modifier z-c++">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-storage z-type z-c">int</span> <span class="z-meta z-method z-c++"><span class="z-entity z-name z-function z-c++">operator()</span></span><span class="z-meta z-method z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-method z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-method z-c++"> <span class="z-storage z-modifier z-c++">const</span> </span><span class="z-meta z-method z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-method z-c++"><span class="z-meta z-block z-c++">
    <span class="z-keyword z-control z-flow z-return z-c++">return</span> x <span class="z-keyword z-operator z-arithmetic z-c">+</span> y<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-method z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></span><span class="z-meta z-class z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>And then later in our code before we want to use <code>add</code> we would have to instantiate an object of this class e.g. via</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++">Adder add<span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>Object-oriented people will rejoice on seeing this because they immediately realise that one could define a base class <code>ArithmeticOperation</code> with a <code>virtual</code> <code>operator()</code> and let <code>Adder</code> inherit from it. The result would be polymorphism through virtual function calls. One could then define a higher-order function that takes two values and an <code>ArithmeticOperation</code> and produces its result like so</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">resultOfCalculation</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-modifier z-c++">const</span> ArithmeticOperation<span class="z-keyword z-operator z-c">&amp;</span> <span class="z-variable z-parameter z-c++">op</span><span class="z-punctuation z-separator z-c++">,</span>
                        <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">op</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>and voilà, there is already a solution for the initial problem. The fact that this approach smells a lot like Java might be a hint that it is probably not the optimal solution. If you need more convincing: Virtual function calls prevent inlining and will make your code less efficient. Also you'd limit the set of possible functions <code>resultOfCalculation</code> can be called on. It will only work on function objects (no normal functions, no lambdas) that inherit from <code>ArithmeticOperation</code>. A more extensible approach can be found further down.</p>
<h3 id="lambdas">Lambdas</h3>
<p>Introduced in C++11, lambdas are in many cases just syntactic sugar for function objects. Their clear advantage is that they can easily be defined <em>anonymously</em> which makes them the perfect candidates to be used with STL algorithms.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">auto</span> add <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-brackets z-c++"><span class="z-punctuation z-section z-brackets z-begin z-c++">[</span><span class="z-punctuation z-section z-brackets z-end z-c++">]</span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-storage z-type z-c">int</span> x<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> y<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span> <span class="z-keyword z-control z-flow z-return z-c++">return</span> x <span class="z-keyword z-operator z-arithmetic z-c">+</span> y<span class="z-punctuation z-terminator z-c++">;</span> <span class="z-punctuation z-section z-block z-end z-c++">}</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>will define <code>add</code> the way we want it. Please note that without <code>auto</code> we would have practically no chance to tell the type of the function literal <code>[](int x, int y) { return x + y; }</code>. We could write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>function<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span><span class="z-storage z-type z-c">int</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-storage z-type z-c">int</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span> add <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-brackets z-c++"><span class="z-punctuation z-section z-brackets z-begin z-c++">[</span><span class="z-punctuation z-section z-brackets z-end z-c++">]</span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-storage z-type z-c">int</span> x<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> y<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span>
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> x <span class="z-keyword z-operator z-arithmetic z-c">+</span> y<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-block z-end z-c++">}</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>but that doesn't mean that the type of the expression is actually <code>std::function&lt;int(int, int)&gt;</code>. What happens is that an object of that type will be created from the object that is created from the expression. Savvy?</p>
<h2 id="passing-functions">Passing Functions</h2>
<p>Back to the original problem of how to pass a function as a parameter to another (higher-order) function.</p>
<p>We want to be able to write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> res <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">resultOfCalculation</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">add<span class="z-punctuation z-separator z-c++">,</span> x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>and expect the result to be the same as just calling <code>add(x, y)</code>. (Ideally we would also want the machine code to do exactly that but let's take one step at a time...)</p>
<p>Assuming we have a function <code>mult</code> that has the same type signature as <code>add</code> (i.e. <code>int(int, int)</code>) but returns the product of its two parameters, we want to be able to interchange <code>add</code> and <code>mult</code> when calling <code>resultOfCalculation</code>.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> sum <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">resultOfCalculation</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">add<span class="z-punctuation z-separator z-c++">,</span> x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-storage z-type z-c">int</span> prod <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">resultOfCalculation</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">mult<span class="z-punctuation z-separator z-c++">,</span> x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>How should we define <code>resultOfCalculation</code>?</p>
<h3 id="function-pointers">Function Pointers</h3>
<p>In the world of C without the ++, this would be the go-to solution.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">resultOfCalculation</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-c">*</span>op<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-storage z-type z-c">int</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-separator z-c++">,</span>
                           <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-keyword z-operator z-c">*</span>op<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>x<span class="z-punctuation z-separator z-c++">,</span> y<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>It works fine for regularly defined functions. On my machine with <code>clang</code>, it works as well for lambdas but that doesn't mean you can expect it to work all the time. Especially if your lambdas are not pure. Neither does it work easily with callable objects.</p>
<h3 id="std-function">std::function</h3>
<p>Defined in the <code>functional</code> header and available since C++11, <code>std::function&lt;&gt;</code> is basically a templated callable class that wraps around anything that can behave like a function.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">resultOfCalculation</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-modifier z-c++">const</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>function<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span><span class="z-storage z-type z-c">int</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-storage z-type z-c">int</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-keyword z-operator z-c">&amp;</span> <span class="z-variable z-parameter z-c++">op</span><span class="z-punctuation z-separator z-c++">,</span>
                        <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">op</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>Usually it will get the job done for you but might not be the most efficient way as hidden copies can occur and a <code>std::function</code> will be constructed.</p>
<h3 id="template-type-deduction">Template Type Deduction</h3>
<p>TTD is a mechanism in C++ that – similarly to <code>auto</code> – allows for types to be deduced at compile time. This enables us to write</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> FN</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">resultOfCalculation</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-storage z-modifier z-c++">const</span> FN<span class="z-keyword z-operator z-c">&amp;</span> <span class="z-variable z-parameter z-c++">op</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">int</span> <span class="z-variable z-parameter z-c++">y</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> </span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">op</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>which also works across the board. The compiler will create one instance of this function for every function it is used with. However in this case all of them will be fully inlined resulting in the best performance since neither do we have to dereference pointers nor construct temporary objects.</p>
<p>This technique relies on duck typing; meaning that the way <code>op</code> is used limits the type it can have. E.g. when we try to pass something that is not callable, we will get a <em>compiler error</em>. A downside is that all possible values of <code>op</code> have to be known at compile time. <em>Concepts</em> in C++17 will help strictly specifying requirements as well as giving more helpful error messages. In this example we could just as well pass in a function that returns something that can be casted into an <code>int</code> and nobody would ever notice.</p>
<h4 id="advanced-ttd">Advanced TTD</h4>
<p>Another way of implementing <code>resultOfCalculation</code> with template magic is the following (thanks to Manuel Schiller for reminding me)</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-meta z-template z-c++"><span class="z-storage z-type z-template z-c++">template</span> <span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span></span><span class="z-meta z-template z-c++"><span class="z-storage z-type z-c++">typename</span> FN<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c++">typename</span> T1<span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c++">typename</span> T2</span><span class="z-meta z-template z-c++"><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span></span>
<span class="z-storage z-type z-c">auto</span> <span class="z-meta z-function z-c++"><span class="z-meta z-toc-list z-full-identifier z-c++"><span class="z-entity z-name z-function z-c++">resultOfCalculation</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function z-parameters z-c++"><span class="z-meta z-group z-c++">
  <span class="z-storage z-modifier z-c++">const</span> FN<span class="z-keyword z-operator z-c">&amp;</span> <span class="z-variable z-parameter z-c++">op</span><span class="z-punctuation z-separator z-c++">,</span>
  <span class="z-storage z-modifier z-c++">const</span> T1<span class="z-keyword z-operator z-c">&amp;</span> <span class="z-variable z-parameter z-c++">x</span><span class="z-punctuation z-separator z-c++">,</span>
  <span class="z-storage z-modifier z-c++">const</span> T2<span class="z-keyword z-operator z-c">&amp;</span> y
<span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-function z-c++"> <span class="z-punctuation z-separator z-c++">-&gt;</span></span> <span class="z-storage z-type z-c++">decltype</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++"><span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">op</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-begin z-c++">{</span></span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++">
  <span class="z-keyword z-control z-flow z-return z-c++">return</span> <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">op</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">x<span class="z-punctuation z-separator z-c++">,</span> y</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-function z-c++"><span class="z-meta z-block z-c++"><span class="z-punctuation z-section z-block z-end z-c++">}</span></span></span>
</span></code></pre>
<p>which is more general than the above as it will work with any function <code>op</code> that can be called with two parameters of arbitrary types <code>T1</code> and <code>T2</code>. It also generalises the resulting return type as the return type of <code>op</code> when called with <code>x</code> and <code>y</code>. One could even make it more general to accept any number of arguments using <em>variadic templates</em> but that would go beyond the scope of this post. In case you are not a fan of <code>decltype</code>, <code>std::result_of</code> is your friend here.</p>
<h2 id="conclusion">Conclusion</h2>
<p>If efficiency is your concern and you don't have new functions appear after compilation, go with function templates. This is also the way STL algorithms take function parameters. <code>std::function</code> can help make your code more readable and especially make the requirements more clear.</p>
<h2 id="code">Code</h2>
<p>A working example of everything discussed in this post can be found in <a href="https://gist.github.com/kdungs/30787bb2f6e65a1bf0ef">this gist</a>.</p>
<h2 id="questions-and-comments">Questions and Comments</h2>
<p><a href="https://github.com/kdungs/dun.gs/issues/4">Go to the corresponding issue on GitHub, in order to discuss this article.</a></p>

</article>

    </main>
  </body>
</html>
