<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kevin's blog: Memory management of C libraries in C++ </title>
    <link rel="stylesheet" href="https://dun.gs/style.css">
    <link rel="stylesheet" type="text/css" href="https://dun.gs/syntax-theme.css">
  </head>
  <body>
    <header>
      <h1><a href="/">Kevin's blog</a></h1>
    </header>
    <main>
      
<article>
  <h1>Memory management of C libraries in C++</h1>
  <aside>
    <p>Posted on 2014-11-06.</p>
  </aside>
  <p>Today, I had some time to play around with <a href="https://libgit2.github.com">libgit2</a>, an excellent C-library for <a href="http://git-scm.com/">Git</a>. But since I was thinking about using it together with the freshly released <a href="https://github.com/facebook/proxygen">Proxygen</a>, the fast HTTP-framework from Facebook, I wanted to use the library functions from C++ from the start.</p>
<p>This was a perfect opportunity to play around with C++ memory management objects in the context of a C-library.</p>
<span id="continue-reading"></span><h2 id="academic-example">Academic Example</h2>
<p>In C-libraries, one often finds the following pattern for construction and destruction of objects on the heap:</p>
<pre data-lang="C" class="language-C z-code"><code class="language-C" data-lang="C"><span class="z-source z-c"><span class="z-storage z-type z-c">typedef</span> <span class="z-storage z-type z-c">struct</span> <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span> <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span>...<span class="z-punctuation z-definition z-comment z-c">*/</span></span> <span class="z-punctuation z-section z-block z-end z-c">}</span></span> <span class="z-entity z-name z-type z-typedef z-c">object_t</span><span class="z-punctuation z-terminator z-c">;</span>
object_t <span class="z-keyword z-operator z-c">*</span><span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">object_new</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-storage z-type z-c">void</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">object_free</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c">object_t <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre>
<p>The important thing here is that <code>object_new()</code> returns an owning pointer and it is the user's responsibility to clean up after use. If the user forgets to call <code>object_free</code>, the memory is leaked.</p>
<p>With <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, C++ offers smart containers for memory management which guarantee that the memory is freed after use. They also allow the user to specify a custom &quot;deleter&quot; which is particularly helpful when dealing with C-library functions.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">uniqueObjectPtr</span> <span class="z-keyword z-operator z-assignment z-c">=</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>unique_ptr<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>object_t<span class="z-punctuation z-separator z-c++">,</span>
                                        <span class="z-storage z-type z-c++">decltype</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++"><span class="z-keyword z-operator z-c">&amp;</span>object_free</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-terminator z-c++">;</span>
uniqueObjectPtr <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">obj</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">{</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">object_new</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-separator z-c++">,</span> object_free</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>A working example of this can be found in <a href="https://github.com/kdungs/cpp-neat/tree/master/ManageC">kdungs/cpp-neat/ManageC</a>.</p>
<h2 id="real-world-example-libgit2">Real World Example: libgit2</h2>
<p>Take for example the following snippet that makes use of libgit2 to load information about a local git repository</p>
<pre data-lang="C" class="language-C z-code"><code class="language-C" data-lang="C"><span class="z-source z-c">git_repository <span class="z-keyword z-operator z-c">*</span>repo <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-language z-c">NULL</span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">git_repository_open</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-c">&amp;</span>repo<span class="z-punctuation z-separator z-c">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>./testrepo<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> Do something with repo. <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">git_repository_free</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">repo</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre>
<p>In a C++-context, we don't want to take care of manually freeing the memory. Instead, we put the resulting repo into a memory managing object, that knows which function to call in order to free the memory.</p>
<pre data-lang="cpp" class="language-cpp z-code"><code class="language-cpp" data-lang="cpp"><span class="z-source z-c++"><span class="z-keyword z-control z-c++">using</span> <span class="z-entity z-name z-type z-using z-c++">uniqueRepositoryPtr</span> <span class="z-keyword z-operator z-assignment z-c">=</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>unique_ptr<span class="z-punctuation z-section z-generic z-begin z-c++">&lt;</span>git_repository<span class="z-punctuation z-separator z-c++">,</span>
                                            <span class="z-storage z-type z-c++">decltype</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span><span class="z-meta z-group z-c++"><span class="z-keyword z-operator z-c">&amp;</span>git_repository_free</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-section z-generic z-end z-c++">&gt;</span><span class="z-punctuation z-terminator z-c++">;</span>
git_repository <span class="z-keyword z-operator z-c++">*</span>rawRepo <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-language z-c++">nullptr</span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">git_repository_open</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-keyword z-operator z-c">&amp;</span>rawRepo<span class="z-punctuation z-separator z-c++">,</span> <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>./testrepo<span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span></span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
uniqueRepositoryPtr <span class="z-meta z-function-call z-c++"><span class="z-variable z-function z-c++">repo</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">{</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-meta z-function-call z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span><span class="z-variable z-function z-c++">move</span><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++">rawRepo</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-separator z-c++">,</span> git_repository_free</span></span><span class="z-meta z-function-call z-c++"><span class="z-meta z-group z-c++"><span class="z-punctuation z-section z-group z-end z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre>
<p>I agree that it is a bit clumsy to first declare a raw pointer that is then moved into the memory managing object. The problem here is that libgit2 uses the return value of most of its functions for error codes and I don't see a way around that.</p>
<p><a href="https://github.com/kdungs/dun.gs/issues/3">Go to the corresponding issue on GitHub, in order to discuss this article.</a></p>

</article>

    </main>
  </body>
</html>
